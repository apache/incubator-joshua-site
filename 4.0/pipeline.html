<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" type="text/css" media="screen,print" href="../joshua4.css" />
    <title>Joshua | The Joshua Pipeline</title>
  </head>

  <body>

    <div id="navbar">
      <a href="http://joshua-decoder.org/">
        <img src="../images/joshua-logo-small.png" width="130px" 
             alt="Joshua logo (picture of a Joshua tree)" />
      </a>

      <p class="infobox">
        <b>Stable version</b><br />
        4.1<br/><br/>
        <b>Release date</b><br />
        2013 January
      </p>

<!--       <div class="infobox"> -->
<!--         <b>AUTO LINKS</b><br/> -->
<!--         <ul> -->
<!--            -->
<!--           <li> Advanced features</li> -->
<!--            -->
<!--           <li> Advanced features</li> -->
<!--            -->
<!--           <li> Advanced features</li> -->
<!--            -->
<!--           <li> Building a language pack</li> -->
<!--            -->
<!--           <li> Building a language pack</li> -->
<!--            -->
<!--           <li> Bundling a configuration</li> -->
<!--            -->
<!--           <li> Contributors</li> -->
<!--            -->
<!--           <li> Decoder configuration parameters</li> -->
<!--            -->
<!--           <li> Decoder configuration parameters</li> -->
<!--            -->
<!--           <li> Decoder configuration parameters</li> -->
<!--            -->
<!--           <li> Decoder configuration parameters</li> -->
<!--            -->
<!--           <li> Frequently Asked Questions</li> -->
<!--            -->
<!--           <li> Common problems</li> -->
<!--            -->
<!--           <li> Frequently Asked Questions</li> -->
<!--            -->
<!--           <li> Common problems</li> -->
<!--            -->
<!--           <li> Features</li> -->
<!--            -->
<!--           <li> Features</li> -->
<!--            -->
<!--           <li> Features</li> -->
<!--            -->
<!--           <li> Features</li> -->
<!--            -->
<!--           <li> Joshua file formats</li> -->
<!--            -->
<!--           <li> Joshua file formats</li> -->
<!--            -->
<!--           <li> Joshua file formats</li> -->
<!--            -->
<!--           <li> Joshua file formats</li> -->
<!--            -->
<!--           <li> </li> -->
<!--            -->
<!--           <li> </li> -->
<!--            -->
<!--           <li> </li> -->
<!--            -->
<!--           <li> Fisher and CALLHOME Spanish English Speech Translation Corpus</li> -->
<!--            -->
<!--           <li> Indian Languages Parallel Corpora</li> -->
<!--            -->
<!--           <li> Joshua 4.0 User Documentation</li> -->
<!--            -->
<!--           <li> Language packs</li> -->
<!--            -->
<!--           <li> Paraphrase Packs</li> -->
<!--            -->
<!--           <li> Joshua releases</li> -->
<!--            -->
<!--           <li> Support</li> -->
<!--            -->
<!--           <li> Getting Started</li> -->
<!--            -->
<!--           <li> Welcome to Joshua</li> -->
<!--            -->
<!--           <li> Joshua documentation</li> -->
<!--            -->
<!--           <li> Joshua documentation</li> -->
<!--            -->
<!--           <li> Installation</li> -->
<!--            -->
<!--           <li> Installation</li> -->
<!--            -->
<!--           <li> Alignment with Jacana</li> -->
<!--            -->
<!--           <li> Alignment with Jacana</li> -->
<!--            -->
<!--           <li> Alignment with Jacana</li> -->
<!--            -->
<!--           <li> Building large LMs with SRILM</li> -->
<!--            -->
<!--           <li> Building large LMs with SRILM</li> -->
<!--            -->
<!--           <li> Building large LMs with SRILM</li> -->
<!--            -->
<!--           <li> Building large LMs with SRILM</li> -->
<!--            -->
<!--           <li> Lattice decoding</li> -->
<!--            -->
<!--           <li> Grammar Packing</li> -->
<!--            -->
<!--           <li> Grammar Packing</li> -->
<!--            -->
<!--           <li> Grammar Packing</li> -->
<!--            -->
<!--           <li> Grammar Packing</li> -->
<!--            -->
<!--           <li> The Joshua Pipeline</li> -->
<!--            -->
<!--           <li> The Joshua Pipeline</li> -->
<!--            -->
<!--           <li> The Joshua Pipeline</li> -->
<!--            -->
<!--           <li> The Joshua Pipeline</li> -->
<!--            -->
<!--           <li> Quick Start</li> -->
<!--            -->
<!--           <li> Quick Start</li> -->
<!--            -->
<!--           <li> Releases</li> -->
<!--            -->
<!--           <li> Server mode</li> -->
<!--            -->
<!--           <li> Server mode</li> -->
<!--            -->
<!--           <li> Server mode</li> -->
<!--            -->
<!--           <li> Installing and running the Joshua Decoder</li> -->
<!--            -->
<!--           <li> Grammar extraction with Thrax</li> -->
<!--            -->
<!--           <li> Grammar extraction with Thrax</li> -->
<!--            -->
<!--           <li> Grammar extraction with Thrax</li> -->
<!--            -->
<!--           <li> Grammar extraction with Thrax</li> -->
<!--            -->
<!--           <li> Building Translation Models</li> -->
<!--            -->
<!--           <li> Building Translation Models</li> -->
<!--            -->
<!--           <li> Building Translation Models</li> -->
<!--            -->
<!--           <li> Building Translation Models</li> -->
<!--            -->
<!--           <li> Pipeline tutorial</li> -->
<!--            -->
<!--           <li> Pipeline tutorial</li> -->
<!--            -->
<!--           <li> Pipeline tutorial</li> -->
<!--            -->
<!--           <li> What's New</li> -->
<!--            -->
<!--           <li> What's New</li> -->
<!--            -->
<!--           <li> Z-MERT</li> -->
<!--            -->
<!--           <li> Z-MERT</li> -->
<!--            -->
<!--           <li> Z-MERT</li> -->
<!--            -->
<!--           <li> Z-MERT</li> -->
<!--            -->
<!--           <li> </li> -->
<!--            -->
<!--           <li> </li> -->
<!--            -->
<!--           <li> </li> -->
<!--            -->
<!--         </ul> -->
<!--       </div>   -->

      <div class="infobox">

        <b>Links</b><br />
        <ul>
          <li> <a href="../index.html">Main</a> </li>
          <li> <a href="pipeline.html">Pipeline</a> </li>
          <li> <a href="step-by-step-instructions.html">Manual walkthrough</a> </li>
          <li> <a href="decoder.html">Decoder</a> </li>
          <li> <a href="server.html">Decoder Server</a> </li>
          <li> <a href="file-formats.html">File formats</a> </li>
          <li> <a href="thrax.html">Grammar Extraction</a> </li>
          <li> <a href="../releases.html">Releases</a> </li>
        </ul>
      </div>

      <div class="infobox">
        <b>Advanced</b><br />
        <ul>
<!--          <li> <a href="packing.html">Grammar packing</a> </li> -->
          <li> <a href="large-lms.html">Building large LMs</a> </li>
          <li> <a href="zmert.html">Running Z-MERT</a> </li>
          <li> <a href="lattice.html">Lattices</a> </li>
          <li> <a href="server.html">TCP/IP server</a> </li>
          <li> <a href="bundle.html">Bundled configuration</a> </li>
        </ul>
      </div>

      <div class="infobox">
        <b>Help</b><br />
        <ul>
          <li> <a href="faq.html">Answers</a> </li>
          <li> <a href="https://groups.google.com/d/forum/joshua_support">Archive</a> </li>
        </ul>
      </div>

      <div class="footer">
        Last updated on April 08, 2016
      </div>

    </div>

    <div id="main">
      <div id="title">
        <h1>The Joshua Pipeline</h1>
      </div>

      <div id="content">
        
        <p>This page describes the Joshua pipeline script, which manages the complexity of training and
evaluating machine translation systems.  The pipeline eases the pain of two related tasks in
statistical machine translation (SMT) research:</p>

<ol>
  <li>
    <p>Training SMT systems involves a complicated process of interacting steps that are time-consuming
and prone to failure.</p>
  </li>
  <li>
    <p>Developing and testing new techniques requires varying parameters at different points in the
pipeline.  Earlier results (which are often expensive) need not be recomputed.</p>
  </li>
</ol>

<p>To facilitate these tasks, the pipeline script:
- Runs the complete SMT pipeline, from corpus normalization and tokenization, through model
  building, tuning, test-set decoding, and evaluation.</p>

<ul>
  <li>
    <p>Caches the results of intermediate steps (using robust SHA-1 checksums on dependencies), so the
pipeline can be debugged or shared across similar runs with (almost) no time spent recomputing
expensive steps.</p>
  </li>
  <li>
    <p>Allows you to jump into and out of the pipeline at a set of predefined places (e.g., the alignment
stage), so long as you provide the missing dependencies.</p>
  </li>
</ul>

<p>The Joshua pipeline script is designed in the spirit of Moses’ <code class="highlighter-rouge">train-model.pl</code>, and shares many of
its features.  It is not as extensive, however, as Moses’
<a href="http://www.statmt.org/moses/?n=FactoredTraining.EMS">Experiment Management System</a>.</p>

<h2 id="installation">Installation</h2>

<p>The pipeline has no <em>required</em> external dependencies.  However, it has support for a number of
external packages, some of which are included with Joshua.</p>

<ul>
  <li>
    <p><a href="http://code.google.com/p/giza-pp/">GIZA++</a></p>

    <p>GIZA++ is the default aligner.  It is included with Joshua, and should compile successfully when
you typed <code class="highlighter-rouge">ant all</code> from the Joshua root directory.  It is not required because you can use the
(included) Berkeley aligner (<code class="highlighter-rouge">--aligner berkeley</code>).</p>
  </li>
  <li>
    <p><a href="http://www.speech.sri.com/projects/srilm/">SRILM</a></p>

    <p>By default, the pipeline uses a Java program from the
<a href="http://code.google.com/p/berkeleylm/">Berkeley LM</a> package that constructs an
Kneser-Ney-smoothed language model in ARPA format from the target side of your training data.  If
you wish to use SRILM instead, you need to do the following:</p>

    <ol>
      <li>Install SRILM and set the <code class="highlighter-rouge">$SRILM</code> environment variable to point to its installed location.</li>
      <li>Add the <code class="highlighter-rouge">--lm-gen srilm</code> flag to your pipeline invocation.</li>
    </ol>

    <p>More information on this is available in the <a href="#lm">LM building section of the pipeline</a>.  SRILM
is not used for representing language models during decoding (and in fact is not supported,
having been supplanted by <a href="http://kheafield.com/code/kenlm/">KenLM</a> and BerkeleyLM).</p>
  </li>
  <li>
    <p><a href="http://hadoop.apache.org/">Hadoop</a></p>

    <p>The pipeline uses the <a href="thrax.html">Thrax grammar extractor</a>, which is built on Hadoop.  If you
have a Hadoop installation, simply ensure that the <code class="highlighter-rouge">$HADOOP</code> environment variable is defined, and
the pipeline will use it automatically at the grammar extraction step.  If you are going to
attempt to extract very large grammars, it is best to have a good-sized Hadoop installation.</p>

    <p>(If you do not have a Hadoop installation, you might consider setting one up.  Hadoop can be
installed in a
<a href="http://hadoop.apache.org/common/docs/r0.20.2/quickstart.html#PseudoDistributed">“pseudo-distributed”</a>
mode that allows it to use just a few machines or a number of processors on a single machine.
The main issue is to ensure that there are a lot of independent physical disks, since in our
experience Hadoop starts to exhibit lots of hard-to-trace problems if there is too much demand on
the disks.)</p>

    <p>If you don’t have a Hadoop installation, there are still no worries.  The pipeline will unroll a
standalone installation and use it to extract your grammar.  This behavior will be triggered if
<code class="highlighter-rouge">$HADOOP</code> is undefined.</p>
  </li>
</ul>

<p>Make sure that the environment variable <code class="highlighter-rouge">$JOSHUA</code> is defined, and you should be all set.</p>

<h2 id="a-basic-pipeline-run">A basic pipeline run</h2>

<p>The pipeline takes a set of inputs (training, tuning, and test data), and creates a set of
intermediate files in the <em>run directory</em>.  By default, the run directory is the current directory,
but it can be changed with the <code class="highlighter-rouge">--rundir</code> parameter.</p>

<p>For this quick start, we will be working with the example that can be found in
<code class="highlighter-rouge">$JOSHUA/examples/pipeline</code>.  This example contains 1,000 sentences of Urdu-English data (the full
dataset is available as part of the
<a href="http://joshua-decoder.org/indian-parallel-corpora/">Indian languages parallel corpora</a> with
100-sentence tuning and test sets with four references each.</p>

<p>Running the pipeline requires two main steps: data preparation and invocation.</p>

<ol>
  <li>
    <p>Prepare your data.  The pipeline script needs to be told where to find the raw training, tuning,
and test data.  A good convention is to place these files in an input/ subdirectory of your run’s
working directory (NOTE: do not use <code class="highlighter-rouge">data/</code>, since a directory of that name is created and used
by the pipeline itself).  The expected format (for each of training, tuning, and test) is a pair
of files that share a common path prefix and are distinguished by their extension:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>input/
      train.SOURCE
      train.TARGET
      tune.SOURCE
      tune.TARGET
      test.SOURCE
      test.TARGET
</code></pre>
    </div>

    <p>These files should be parallel at the sentence level (with one sentence per line), should be in
UTF-8, and should be untokenized (tokenization occurs in the pipeline).  SOURCE and TARGET denote
variables that should be replaced with the actual target and source language abbreviations (e.g.,
“ur” and “en”).</p>
  </li>
  <li>
    <p>Run the pipeline.  The following is the minimal invocation to run the complete pipeline:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>$JOSHUA/scripts/training/pipeline.pl  \
  --corpus input/train                \
  --tune input/tune                   \
  --test input/devtest                \
  --source SOURCE                     \
  --target TARGET
</code></pre>
    </div>

    <p>The <code class="highlighter-rouge">--corpus</code>, <code class="highlighter-rouge">--tune</code>, and <code class="highlighter-rouge">--test</code> flags define file prefixes that are concatened with the
language extensions given by <code class="highlighter-rouge">--target</code> and <code class="highlighter-rouge">--source</code> (with a “.” in betwee).  Note the
correspondences with the files defined in the first step above.  The prefixes can be either
absolute or relative pathnames.  This particular invocation assumes that a subdirectory <code class="highlighter-rouge">input/</code>
exists in the current directory, that you are translating from a language identified “ur”
extension to a language identified by the “en” extension, that the training data can be found at
<code class="highlighter-rouge">input/train.en</code> and <code class="highlighter-rouge">input/train.ur</code>, and so on.</p>
  </li>
</ol>

<p>Assuming no problems arise, this command will run the complete pipeline in about 20 minutes,
producing BLEU scores at the end.  As it runs, you will see output that looks like the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[train-copy-en] rebuilding...
  dep=/Users/post/code/joshua/test/pipeline/input/train.en 
  dep=data/train/train.en.gz [NOT FOUND]
  cmd=cat /Users/post/code/joshua/test/pipeline/input/train.en | gzip -9n &gt; data/train/train.en.gz
  took 0 seconds (0s)
[train-copy-ur] rebuilding...
  dep=/Users/post/code/joshua/test/pipeline/input/train.ur 
  dep=data/train/train.ur.gz [NOT FOUND]
  cmd=cat /Users/post/code/joshua/test/pipeline/input/train.ur | gzip -9n &gt; data/train/train.ur.gz
  took 0 seconds (0s)
...
</code></pre>
</div>

<p>And in the current directory, you will see the following files (among other intermediate files
generated by the individual sub-steps).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data/
    train/
        corpus.ur
        corpus.en
        thrax-input-file
    tune/
        tune.tok.lc.ur
        tune.tok.lc.en
        grammar.filtered.gz
        grammar.glue
    test/
        test.tok.lc.ur
        test.tok.lc.en
        grammar.filtered.gz
        grammar.glue
alignments/
    0/
        [berkeley aligner output files]
    training.align
thrax-hiero.conf
thrax.log
grammar.gz
lm.gz
tune/
    1/
        decoder_command
        joshua.config
        params.txt
        joshua.log
        mert.log
        joshua.config.ZMERT.final
    final-bleu
</code></pre>
</div>

<p>These files will be described in more detail in subsequent sections of this tutorial.</p>

<p>Another useful flag is the <code class="highlighter-rouge">--rundir DIR</code> flag, which chdir()s to the specified directory before
running the pipeline.  By default the rundir is the current directory.  Changing it can be useful
for organizing related pipeline runs.  Relative paths specified to other flags (e.g., to <code class="highlighter-rouge">--corpus</code>
or <code class="highlighter-rouge">--lmfile</code>) are relative to the directory the pipeline was called <em>from</em>, not the rundir itself
(unless they happen to be the same, of course).</p>

<p>The complete pipeline comprises many tens of small steps, which can be grouped together into a set
of traditional pipeline tasks:</p>

<ol>
  <li><a href="#prep">Data preparation</a></li>
  <li><a href="#alignment">Alignment</a></li>
  <li><a href="#parsing">Parsing</a></li>
  <li><a href="#tm">Grammar extraction</a></li>
  <li><a href="#lm">Language model building</a></li>
  <li><a href="#tuning">Tuning</a></li>
  <li><a href="#testing">Testing</a></li>
</ol>

<p>These steps are discussed below, after a few intervening sections about high-level details of the
pipeline.</p>

<h2 id="grammar-options">Grammar options</h2>

<p>Joshua can extract two types of grammars: Hiero-style grammars and SAMT grammars.  As described on
the <a href="file-formats.html">file formats page</a>, both of them are encoded into the same file format, but
they differ in terms of the richness of their nonterminal sets.</p>

<p>Hiero grammars make use of a single nonterminals, and are extracted by computing phrases from
word-based alignments and then subtracting out phrase differences.  More detail can be found in
<a href="http://www.mitpressjournals.org/doi/abs/10.1162/coli.2007.33.2.201">Chiang (2007) [PDF]</a>.
<a href="http://www.cs.cmu.edu/~zollmann/samt/">SAMT grammars</a> make use of a source- or target-side parse
tree on the training data, projecting constituent labels down on the phrasal alignments in a variety
of configurations.  SAMT grammars are usually many times larger and are much slower to decode with,
but sometimes increase BLEU score.  Both grammar formats are extracted with the
<a href="thrax.html">Thrax software</a>.</p>

<p>By default, the Joshua pipeline extract a Hiero grammar, but this can be altered with the <code class="highlighter-rouge">--type
samt</code> flag.</p>

<h2 id="other-high-level-options">Other high-level options</h2>

<p>The following command-line arguments control run-time behavior of multiple steps:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">--threads N</code> (1)</p>

    <p>This enables multithreaded operation for a number of steps: alignment (with GIZA, max two
threads), parsing, and decoding (any number of threads)</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--jobs N</code> (1)</p>

    <p>This enables parallel operation over a cluster using the qsub command.  This feature is not
well-documented at this point, but you will likely want to edit the file
<code class="highlighter-rouge">$JOSHUA/scripts/training/parallelize/LocalConfig.pm</code> to setup your qsub environment, and may also
want to pass specific qsub commands via the <code class="highlighter-rouge">--qsub-args "ARGS"</code> command.</p>
  </li>
</ul>

<h2 id="restarting-failed-runs">Restarting failed runs</h2>

<p>If the pipeline dies, you can restart it with the same command you used the first time.  If you
rerun the pipeline with the exact same invocation as the previous run (or an overlapping
configuration – one that causes the same set of behaviors), you will see slightly different
output compared to what we saw above:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[train-copy-en] cached, skipping...
[train-copy-ur] cached, skipping...
...
</code></pre>
</div>

<p>This indicates that the caching module has discovered that the step was already computed and thus
did not need to be rerun.  This feature is quite useful for restarting pipeline runs that have
crashed due to bugs, memory limitations, hardware failures, and the myriad other problems that
plague MT researchers across the world.</p>

<p>Often, a command will die because it was parameterized incorrectly.  For example, perhaps the
decoder ran out of memory.  This allows you to adjust the parameter (e.g., <code class="highlighter-rouge">--joshua-mem</code>) and rerun
the script.  Of course, if you change one of the parameters a step depends on, it will trigger a
rerun, which in turn might trigger further downstream reruns.</p>

<h2 id="skipping-steps-quitting-early">Skipping steps, quitting early</h2>

<p>You will also find it useful to start the pipeline somewhere other than data preparation (for
example, if you have already-processed data and an alignment, and want to begin with building a
grammar) or to end it prematurely (if, say, you don’t have a test set and just want to tune a
model).  This can be accomplished with the <code class="highlighter-rouge">--first-step</code> and <code class="highlighter-rouge">--last-step</code> flags, which take as
argument a case-insensitive version of the following steps:</p>

<ul>
  <li>
    <p><em>FIRST</em>: Data preparation.  Everything begins with data preparation.  This is the default first
 step, so there is no need to be explicit about it.</p>
  </li>
  <li>
    <p><em>ALIGN</em>: Alignment.  You might want to start here if you want to skip data preprocessing.</p>
  </li>
  <li>
    <p><em>PARSE</em>: Parsing.  This is only relevant for building SAMT grammars (<code class="highlighter-rouge">--type samt</code>), in which case
 the target side (<code class="highlighter-rouge">--target</code>) of the training data (<code class="highlighter-rouge">--corpus</code>) is parsed before building a
 grammar.</p>
  </li>
  <li>
    <p><em>THRAX</em>: Grammar extraction <a href="thrax.html">with Thrax</a>.  If you jump to this step, you’ll need to
 provide an aligned corpus (<code class="highlighter-rouge">--alignment</code>) along with your parallel data.  </p>
  </li>
  <li>
    <p><em>TUNE</em>: Tuning.  The exact tuning method is determined with <code class="highlighter-rouge">--tuner {mert,pro}</code>.  With this
 option, you need to specify a grammar (<code class="highlighter-rouge">--grammar</code>) or separate tune (<code class="highlighter-rouge">--tune-grammar</code>) and test
 (<code class="highlighter-rouge">--test-grammar</code>) grammars.  A full grammar (<code class="highlighter-rouge">--grammar</code>) will be filtered against the relevant
 tuning or test set unless you specify <code class="highlighter-rouge">--no-filter-tm</code>.  If you want a language model built from
 the target side of your training data, you’ll also need to pass in the training corpus
 (<code class="highlighter-rouge">--corpus</code>).  You can also specify an arbitrary number of additional language models with one or
 more <code class="highlighter-rouge">--lmfile</code> flags.</p>
  </li>
  <li>
    <p><em>TEST</em>: Testing.  If you have a tuned model file, you can test new corpora by passing in a test
 corpus with references (<code class="highlighter-rouge">--test</code>).  You’ll need to provide a run name (<code class="highlighter-rouge">--name</code>) to store the
 results of this run, which will be placed under <code class="highlighter-rouge">test/NAME</code>.  You’ll also need to provide a
 Joshua configuration file (<code class="highlighter-rouge">--joshua-config</code>), one or more language models (<code class="highlighter-rouge">--lmfile</code>), and a
 grammar (<code class="highlighter-rouge">--grammar</code>); this will be filtered to the test data unless you specify
 <code class="highlighter-rouge">--no-filter-tm</code>) or unless you directly provide a filtered test grammar (<code class="highlighter-rouge">--test-grammar</code>).</p>
  </li>
  <li>
    <p><em>LAST</em>: The last step.  This is the default target of <code class="highlighter-rouge">--last-step</code>.</p>
  </li>
</ul>

<p>We now discuss these steps in more detail.</p>

<p><a name="prep"></a>
## 1. DATA PREPARATION</p>

<p>Data prepare involves doing the following to each of the training data (<code class="highlighter-rouge">--corpus</code>), tuning data
(<code class="highlighter-rouge">--tune</code>), and testing data (<code class="highlighter-rouge">--test</code>).  Each of these values is an absolute or relative path
prefix.  To each of these prefixes, a “.” is appended, followed by each of SOURCE (<code class="highlighter-rouge">--source</code>) and
TARGET (<code class="highlighter-rouge">--target</code>), which are file extensions identifying the languages.  The SOURCE and TARGET
files must have the same number of lines.  </p>

<p>For tuning and test data, multiple references are handled automatically.  A single reference will
have the format TUNE.TARGET, while multiple references will have the format TUNE.TARGET.NUM, where
NUM starts at 0 and increments for as many references as there are.</p>

<p>The following processing steps are applied to each file.</p>

<ol>
  <li>
    <p><strong>Copying</strong> the files into <code class="highlighter-rouge">RUNDIR/data/TYPE</code>, where TYPE is one of “train”, “tune”, or “test”.
Multiple <code class="highlighter-rouge">--corpora</code> files are concatenated in the order they are specified.  Multiple <code class="highlighter-rouge">--tune</code>
and <code class="highlighter-rouge">--test</code> flags are not currently allowed.</p>
  </li>
  <li>
    <p><strong>Normalizing</strong> punctuation and text (e.g., removing extra spaces, converting special
quotations).  There are a few language-specific options that depend on the file extension
matching the <a href="http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">two-letter ISO 639-1</a>
designation.</p>
  </li>
  <li>
    <p><strong>Tokenizing</strong> the data (e.g., separating out punctuation, converting brackets).  Again, there
are language-specific tokenizations for a few languages (English, German, and Greek).</p>
  </li>
  <li>
    <p>(Training only) <strong>Removing</strong> all parallel sentences with more than <code class="highlighter-rouge">--maxlen</code> tokens on either
side.  By default, MAXLEN is 50.  To turn this off, specify <code class="highlighter-rouge">--maxlen 0</code>.</p>
  </li>
  <li>
    <p><strong>Lowercasing</strong>.</p>
  </li>
</ol>

<p>This creates a series of intermediate files which are saved for posterity but compressed.  For
example, you might see</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data/
    train/
        train.en.gz
        train.tok.en.gz
        train.tok.50.en.gz
        train.tok.50.lc.en
        corpus.en -&gt; train.tok.50.lc.en
</code></pre>
</div>

<p>The file “corpus.LANG” is a symbolic link to the last file in the chain.  </p>

<p><a name="alignment"></a>
## 2. ALIGNMENT</p>

<p>Alignments are between the parallel corpora at <code class="highlighter-rouge">RUNDIR/data/train/corpus.{SOURCE,TARGET}</code>.  To
prevent the alignment tables from getting too big, the parallel corpora are grouped into files of no
more than ALIGNER_CHUNK_SIZE blocks (controlled with a parameter below).  The last block is folded
into the penultimate block if it is too small.  These chunked files are all created in a
subdirectory of <code class="highlighter-rouge">RUNDIR/data/train/splits</code>, named <code class="highlighter-rouge">corpus.LANG.0</code>, <code class="highlighter-rouge">corpus.LANG.1</code>, and so on.</p>

<p>The pipeline parameters affecting alignment are:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">aligner ALIGNER</code> {giza (default), berkeley}</p>

    <p>Which aligner to use.  The default is <a href="http://code.google.com/p/giza-pp/">GIZA++</a>, but
<a href="http://code.google.com/p/berkeleyaligner/">the Berkeley aligner</a> can be used instead.  When
using the Berkeley aligner, you’ll want to pay attention to how much memory you allocate to it
with <code class="highlighter-rouge">--aligner-mem</code> (the default is 10g).</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">aligner-chunk-size SIZE</code> (1,000,000)</p>

    <p>The number of sentence pairs to compute alignments over.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--alignment FILE</code></p>

    <p>If you have an already-computed alignment, you can pass that to the script using this flag.
Note that, in this case, you will want to skip data preparation and alignment using
<code class="highlighter-rouge">--first-step thrax</code> (the first step after alignment) and also to specify <code class="highlighter-rouge">--no-prepare-data</code> so
as not to retokenize the data and mess with your alignments.</p>

    <p>The alignment file format is the standard format where 0-indexed many-many alignment pairs for a
sentence are provided on a line, source language first, e.g.,</p>

    <p>0-0 0-1 1-2 1-7 …</p>

    <p>This value is required if you start at the grammar extraction step.</p>
  </li>
</ul>

<p>When alignment is complete, the alignment file can be found at <code class="highlighter-rouge">RUNDIR/alignments/training.align</code>.
It is parallel to the training corpora.  There are many files in the <code class="highlighter-rouge">alignments/</code> subdirectory that
contain the output of intermediate steps.</p>

<p><a name="parsing"></a>
## 3. PARSING</p>

<p>When SAMT grammars are being built (<code class="highlighter-rouge">--type samt</code>), the target side of the training data must be
parsed.  The pipeline assumes your target side will be English, and will parse it for you using
<a href="http://code.google.com/p/berkeleyparser/">the Berkeley parser</a>, which is included.  If it is not
the case that English is your target-side language, the target side of your training data (found at
CORPUS.TARGET) must already be parsed in PTB format.  The pipeline will notice that it is parsed and
will not reparse it.</p>

<p>Parsing is affected by both the <code class="highlighter-rouge">--threads N</code> and <code class="highlighter-rouge">--jobs N</code> options.  The former runs the parser in
multithreaded mode, while the latter distributes the runs across as cluster (and requires some
configuration, not yet documented).  The options are mutually exclusive.</p>

<p>Once the parsing is complete, there will be two parsed files:</p>

<ul>
  <li><code class="highlighter-rouge">RUNDIR/data/train/corpus.en.parsed</code>: this is the mixed-case file that was parsed.</li>
  <li><code class="highlighter-rouge">RUNDIR/data/train/corpus.parsed.en</code>: this is a leaf-lowercased version of the above file used for
grammar extraction.</li>
</ul>

<p><a name="tm"></a>
## 4. THRAX (grammar extraction)</p>

<p>The grammar extraction step takes three pieces of data: (1) the source-language training corpus, (2)
the target-language training corpus (parsed, if an SAMT grammar is being extracted), and (3) the
alignment file.  From these, it computes a synchronous context-free grammar.  If you already have a
grammar and wish to skip this step, you can do so passing the grammar with the <code class="highlighter-rouge">--grammar GRAMMAR</code>
flag. </p>

<p>The main variable in grammar extraction is Hadoop.  If you have a Hadoop installation, simply ensure
that the environment variable <code class="highlighter-rouge">$HADOOP</code> is defined, and Thrax will seamlessly use it.  If you <em>do
not</em> have a Hadoop installation, the pipeline will roll out out for you, running Hadoop in
standalone mode.  (This mode is triggered when <code class="highlighter-rouge">$HADOOP</code> is undefined).  Theoretically, any grammar extractable on a full Hadoop cluster should be
extractable in standalone mode, if you are patient enough; in practice, you probably are not patient
enough, and will be limited to smaller datasets.  Setting up your own Hadoop cluster is not too
difficult a chore; in particular, you may find it helpful to install a
<a href="http://hadoop.apache.org/common/docs/r0.20.2/quickstart.html">pseudo-distributed version of Hadoop</a>.
In our experience, this works fine, but you should note the following caveats:</p>

<ul>
  <li>It is of crucial importance that you have enough physical disks.  We have found that having too
few, or too slow of disks, results in a whole host of seemingly unrelated issues that are hard to
resolve, such as timeouts.  </li>
  <li>NFS filesystems can exacerbate this.  You should really try to install physical disks that are
dedicated to Hadoop scratch space.</li>
</ul>

<p>Here are some flags relevant to Hadoop and grammar extraction with Thrax:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">--hadoop /path/to/hadoop</code></p>

    <p>This sets the location of Hadoop (overriding the environment variable <code class="highlighter-rouge">$HADOOP</code>)</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--hadoop-mem MEM</code> (2g)</p>

    <p>This alters the amount of memory available to Hadoop mappers (passed via the
<code class="highlighter-rouge">mapred.child.java.opts</code> options).</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--thrax-conf FILE</code></p>

    <p>Use the provided Thrax configuration file instead of the (grammar-specific) default.  The Thrax
 templates are located at <code class="highlighter-rouge">$JOSHUA/scripts/training/templates/thrax-TYPE.conf</code>, where TYPE is one
 of “hiero” or “samt”.</p>
  </li>
</ul>

<p>When the grammar is extracted, it is compressed and placed at <code class="highlighter-rouge">RUNDIR/grammar.gz</code>.</p>

<p><a name="lm"></a>
## 5. Language model</p>

<p>Before tuning can take place, a language model is needed.  A language model is always built from the
target side of the training corpus unless <code class="highlighter-rouge">--no-corpus-lm</code> is specified.  In addition, you can
provide other language models (any number of them) with the <code class="highlighter-rouge">--lmfile FILE</code> argument.  Other
arguments are as follows.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">--lm</code> {kenlm (default), berkeleylm}</p>

    <p>This determines the language model code that will be used when decoding.  These implementations
are described in their respective papers (PDFs:
<a href="http://kheafield.com/professional/avenue/kenlm.pdf">KenLM</a>,
<a href="http://nlp.cs.berkeley.edu/pubs/Pauls-Klein_2011_LM_paper.pdf">BerkeleyLM</a>).</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--lmfile FILE</code></p>

    <p>Specifies a pre-built language model to use when decoding.  This language model can be in ARPA
format, or in KenLM format when using KenLM or BerkeleyLM format when using that format.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--lm-gen</code> {berkeleylm (default), srilm}, <code class="highlighter-rouge">--buildlm-mem MEM</code>, <code class="highlighter-rouge">--witten-bell</code></p>

    <p>At the tuning step, an LM is built from the target side of the training data (unless
<code class="highlighter-rouge">--no-corpus-lm</code> is specified).  This controls which code is used to build it.  The default is a
<a href="http://code.google.com/p/berkeleylm/source/browse/trunk/src/edu/berkeley/nlp/lm/io/MakeKneserNeyArpaFromText.java">BerkeleyLM java class</a>
that computes a Kneser-Ney LM with a constant discounting and no count thresholding.  The flag
<code class="highlighter-rouge">--buildlm-mem</code> can be used to control how much memory is allocated to the Java process.  The
default is “2g”, but you will want to increase it for larger language models.</p>

    <p>If SRILM is used, it is called with the following arguments:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  $SRILM/bin/i686-m64/ngram-count -interpolate SMOOTHING -order 5 -text TRAINING-DATA -unk -lm lm.gz
</code></pre>
    </div>

    <p>Where SMOOTHING is <code class="highlighter-rouge">-kndiscount</code>, or <code class="highlighter-rouge">-wbdiscount</code> if <code class="highlighter-rouge">--witten-bell</code> is passed to the pipeline.</p>
  </li>
</ul>

<p>A language model built from the target side of the training data is placed at <code class="highlighter-rouge">RUNDIR/lm.gz</code>.  </p>

<h2 id="interlude-decoder-arguments">Interlude: decoder arguments</h2>

<p>Running the decoder is done in both the tuning stage and the testing stage.  A critical point is
that you have to give the decoder enough memory to run.  Joshua can be very memory-intensive, in
particular when decoding with large grammars and large language models.  The default amount of
memory is 3100m, which is likely not enough (especially if you are decoding with SAMT grammar).  You
can alter the amount of memory for Joshua using the <code class="highlighter-rouge">--joshua-mem MEM</code> argument, where MEM is a Java
memory specification (passed to its <code class="highlighter-rouge">-Xmx</code> flag).</p>

<p><a name="tuning"></a>
## 6. TUNING</p>

<p>Two optimizers are implemented for Joshua: MERT and PRO (<code class="highlighter-rouge">--tuner {mert,pro}</code>).  Tuning is run till
convergence in the <code class="highlighter-rouge">RUNDIR/tune</code> directory.  By default, tuning is run just once, but the pipeline
supports running the optimizer an arbitrary number of times due to
<a href="http://www.youtube.com/watch?v=BOa3XDkgf0Y">recent work</a> pointing out the variance of tuning
procedures in machine translation, in particular MERT.  This can be activated with <code class="highlighter-rouge">--optimizer-runs
N</code>.  Each run can be found in a directory <code class="highlighter-rouge">RUNDIR/tune/N</code>.</p>

<p>When
tuning is finished, each final configuration file can be found at either</p>

<div class="highlighter-rouge"><pre class="highlight"><code>RUNDIR/tune/N/joshua.config.ZMERT.final
RUNDIR/tune/N/joshua.config.PRO.final
</code></pre>
</div>

<p>where N varies from 1..<code class="highlighter-rouge">--optimizer-runs</code>.</p>

<p><a name="testing"></a>
## 7. Testing</p>

<p>For each of the tuner runs, Joshua takes the tuner output file and decodes the test set.
Afterwards, by default, minimum Bayes-risk decoding is run on the 300-best output.  This step
usually yields about 0.3 - 0.5 BLEU points but is time-consuming, and can be turned off with the
<code class="highlighter-rouge">--no-mbr</code> flag. </p>

<p>After decoding the test set with each set of tuned weights, Joshua computes the mean BLEU score,
writes it to <code class="highlighter-rouge">RUNDIR/test/final-bleu</code>, and cats it.  That’s the end of the pipeline!</p>

<p>Joshua also supports decoding further test sets.  This is enabled by rerunning the pipeline with a
number of arguments:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">--first-step TEST</code></p>

    <p>This tells the decoder to start at the test step.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--name NAME</code></p>

    <p>A name is needed to distinguish this test set from the previous ones.  Output for this test run
will be stored at <code class="highlighter-rouge">RUNDIR/test/NAME</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">--joshua-config CONFIG</code></p>

    <p>A tuned parameter file is required.  This file will be the output of some prior tuning run.
Necessary pathnames and so on will be adjusted.</p>
  </li>
</ul>

<h2 id="common-use-cases-and-pitfalls">COMMON USE CASES AND PITFALLS</h2>

<ul>
  <li>
    <p>If the pipeline dies at the “thrax-run” stage with an error like the following:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>JOB FAILED (return code 1) 
hadoop/bin/hadoop: line 47: 
/some/path/to/a/directory/hadoop/bin/hadoop-config.sh: No such file or directory 
Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/hadoop/fs/FsShell 
Caused by: java.lang.ClassNotFoundException: org.apache.hadoop.fs.FsShell 
</code></pre>
    </div>

    <p>This occurs if the <code class="highlighter-rouge">$HADOOP</code> environment variable is set but does not point to a working
Hadoop installation.  To fix it, make sure to unset the variable:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code># in bash
unset HADOOP
</code></pre>
    </div>

    <p>and then rerun the pipeline with the same invocation.</p>
  </li>
  <li>
    <p>Memory usage is a major consideration in decoding with Joshua and hierarchical grammars.  In
particular, SAMT grammars often require a large amount of memory.  Many steps have been taken to
reduce memory usage, including beam settings and test-set- and sentence-level filtering of
grammars.  However, memory usage can still be in the tens of gigabytes.</p>

    <p>To accommodate this kind of variation, the pipeline script allows you to specify both (a) the
amount of memory used by the Joshua decoder instance and (b) the amount of memory required of
nodes obtained by the qsub command.  These are accomplished with the <code class="highlighter-rouge">--joshua-mem</code> MEM and
<code class="highlighter-rouge">--qsub-args</code> ARGS commands.  For example,</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>pipeline.pl --joshua-mem 32g --qsub-args "-l pvmem=32g -q himem.q" ...
</code></pre>
    </div>

    <p>Also, should Thrax fail, it might be due to a memory restriction. By default, Thrax requests 2 GB
from the Hadoop server. If more memory is needed, set the memory requirement with the
<code class="highlighter-rouge">--hadoop-mem</code> in the same way as the <code class="highlighter-rouge">--joshua-mem</code> option is used.</p>
  </li>
  <li>
    <p>Other pitfalls and advice will be added as it is discovered.</p>
  </li>
</ul>

<h2 id="feedback">FEEDBACK</h2>

<p>Please email joshua_support@googlegroups.com with problems or suggestions.</p>



      </div>
    </div>

  </body>
</html>





